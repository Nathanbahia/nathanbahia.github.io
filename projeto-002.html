<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300&display=swap">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css">
    <link rel="stylesheet" href="src/css/prism.css">
    <link rel="stylesheet" href="src/css/estilo.css">
    <title>@NoobPythonBR</title>
  </head>
  <body>
	
	<header class='container-fluid'>
		<img src='src/images/banner.jpg' id='banner'>
		<ul class='navbar nav '>
			<li><a target="blank" href="https://github.com/Nathanbahia"><i class="fab fa-github-square"></i></a></li>
			<li><a target="blank" href="https://linkedin.com/in/nathanbahia"><i class="fab fa-linkedin"></i></a></li>
			<li><a target="blank" href="https://instagram.com/noobpythonbr"><i class="fab fa-instagram"></i></a></li>
		</ul>
		<h1 class="myname">P-002 - Bora jogar um 21?</h1>
		<a class="btn btn-outline-warning" href="https://github.com/Nathanbahia/noobpythonbr" target="_blank">Acesse o repositório no GitHub</a>
	</header>
	
	<hr>
	    <button class="btn btn-danger"><a href="index.html">Voltar à Página Inicial</a></button>
	<hr>

	<main class='container'>
	   
	    
	    <div class="comment">
	        <p>Mais um projeto para treinar os conceitos de Programação Orientada a Objetos. Dessa vez, tentei criar uma partida de 21, onde cada carta é um objeto da classe Card. Um deck armazena várias instâncias de cartas. Um player retira cartas do deck e guarda em sua mão.</p>
	        <p>Estudar orientação a objetos é massa por conta disso. Você consegue trazer para dentro do código coisas do mundo real, representando suas qualidades (propriedades) e ações (métodos).</p>
	        <p>Acesse o repositório no GitHub para ter acesso a esse e outros projetos.</p>
	    </div>
	    
    	<div class="codigo">
        	<pre><code class="language-python">
''' Importação dos módulos necessários para o projeto '''
from time import sleep
from random import shuffle, choice

class Card:
	'''
	Criação da classe Card. Esta classe possui dois atributos:
		- naipe e valor (assim como as cartas da vida real)
		
	O método __init__ é o método construtor que recebe os parâmetros
	naipe e valor e os atribui às propriedades self.naipe e self.valor
	'''
	def __init__(self, naipe, valor):
		self.naipe = naipe
		self.valor = valor

	'''
	O método __str__ serve para definir como deve ser impresso o objeto da classe.
	
	Aqui, estou usando os valores das propriedades para formatar a exibição
	das cartas do modo como as conhecemos, pois como será mostrado na classe Deck,
	a formação de um objeto Card se dá apenas com a passagem de parâmetros numéricos.
	'''
	def __str__(self):
		''' Cartas especiais '''
		if   self.valor ==  1: valor = "Ás"
		elif self.valor == 11: valor = "Valete"
		elif self.valor == 12: valor = "Rainha"
		elif self.valor == 13: valor = "Rei"
		else:
			''' Cartas normais '''
			valor = self.valor

		''' Os naipes são dados como números e alterados aqui abaixo '''
		if self.naipe == 0: return f"{valor} de Ouros"
		if self.naipe == 1: return f"{valor} de Copas"
		if self.naipe == 2: return f"{valor} de Espadas"
		if self.naipe == 3: return f"{valor} de Paus"



class Deck:
	'''
	Criação da classe Deck (baralho). Para a criação de um objeto desta
	classe não é necessária a passagem de parâmetros.
	
	Dentro do proprio método construtor __init__, através de um loop
	for, são criadas 52 instâncias da classe Card, que recebem o valor de
	naipe e valor a cada iteração do loop.
	
	Esses objetos criados são armazenados dentro da propriedade do Deck
	self.cards. Ou seja, temos uma classe (Deck) que armazena cartas (Card)
	'''
	def __init__(self):
		self.cards = []

		for naipe in range(4):
			for valor in range(1, 14):
				newCard = Card(naipe, valor)
				self.cards.append(newCard)

		''' A função shuffle mistura nosso baralho '''
		shuffle(self.cards)


class Player:
	'''
	Criação da classe Player. Essa classe possui um parâmetro opcional (name),
	que caso não seja passado, recebe o valor padrão 'Programador'.
	
	Essa classe possui uma lista como propriedade que representa a mão do jogador,
	que assim como a propriedade self.cards do Deck, self.hand armazena objetos Cards.
	'''
	def __init__(self, name='Programador'):
		self.name = name
		self.hand = []


	'''
	Esse método calcula a quantidade de pontos que o jogador tem em mãos,
	usando um loop for, é somado à variável score a propriedade valor de
	cada instância de classe Card que ele possuir.
	'''
	def get_hand_score(self):
		score = 0
		for c in self.hand:
			score += c.valor
		return score


class Game:
	'''
	Aqui é onde está toda a lógica do jogo.
	
	Essa classe usa como parâmetros para do método construtor __init__
	uma lista com objetos Player e um objeto Deck.
	
	Possui ainda como propriedades pré-determinadas self.round, que vai
	gerenciar as rodadas, e self.winners que vai armazenas os vencedores.
	'''
	def __init__(self, players, deck):
		self.players = players
		self.deck = deck
		self.round = 0
		self.winners = []
		
		
	''' Recebe um objeto player e retorna True se tiver mais de 21 pontos '''
	def check_if_is_not_over(self, p):
		if p.get_hand_score() > 21:
			return True

	''' Recebe um objeto player e retorna True se tiver exatamente 21 pontos '''
	def check_if_win(self, p):
		if p.get_hand_score() == 21:
			return True
			

	'''
	Este método é um pouquinho mais complicado de comentar, mas bora lá...

	A partir da comparação de self.round e do tamanho da lista de players (self.players),
	o jogador cujo índice dentro da lista self.players corresponde ao valor
	de self.round retira uma carta do deck (deck = instância da classe Deck).

	Uma mensagem é exibida contendo o nome do player, a carta que ele retirou e quantidade
	de pontos que as cartas em sua mão somam.

	Após isso, é verificado se o player estorou ou ganhou. Caso qualquer uma das
	verificações retornem True, o player é removido da lista de players (self.players).
	Se ele ganhou, além de ser removido da lista de players, é adicionado a lista de
	vencedores (self.winners).

	Se houver a remoção de um player nos caso citados acima, e ainda restarem jogadores,
	um outro jogador é escolhido ao acaso para continuar a partida.

	Senão acontecer nenhum dos casos acima, self.round é acrescida de +1 e o próximo
	jogador retira uma carta.

	Caso self.round tenha o valor igual ao tamanho da lista de players, seu valor retorna
	ao zero, ou seja, para o início da lista.

	'''
	def give_cards(self):
		if self.round < len(self.players):
			carta = self.deck.cards.pop()
			self.players[self.round].hand.append(carta)
			print(self.players[self.round].name, 'retirou a carta ', carta, ' \
e agora tem ', self.players[self.round].get_hand_score(), ' pontos.')

			''' Verifica se estorou '''
			if self.check_if_is_not_over(self.players[self.round]):
				print(self.players[self.round].name, ' está fora.')
				del self.players[self.round]
				
				if len(self.players) > 1:
					self.round = choice(list(range(len(self.players))))

				''' Verifica se ganhou '''
			elif self.check_if_win(self.players[self.round]):
				print(self.players[self.round].name, ' venceu.')
				self.winners.append(self.players[self.round])
				del self.players[self.round]
				
				if len(self.players) > 1:
					self.round = choice(list(range(len(self.players))))
			else:
				self.round += 1
		else:
			self.round = 0
			
		''' Só pra dar um espaçamento entre um e outro :) '''
		print()
		

''' Criação dos jogadores '''
p1 = Player('Nathan Bahia')
p2 = Player('Guido van Rossum ')
p3 = Player('Brendan Eich')
p4 = Player('Tim Berners-Lee')

''' Criação da lista de jogadores '''
players = [p1, p2, p3, p4]

''' Criação do baralho '''
deck = Deck()

''' Criação do objetos Game '''
game = Game(players, deck)


'''
Loop principal que será executado enquanto ainda houver jogadores na lista players
do objeto game que ainda não tenham vencido ou estourado.
'''
while len(game.players) > 0:
	game.give_cards()
	sleep(.3)

'''
Após o término do loop while acima, se houverem ganhadores, seus nomes
serão exibidos aqui
'''
if len(game.winners) > 0:
	print("Vencedor (es):")
	for winner in game.winners:
		print(winner.name)
	
else:
	print("Ninguém venceu!")
            </code></pre>
    
    
	</main>
	
	<footer class="footer">
	    <div class="container">
	        <div>
				<p id="assinatura">Nathan Bahia</p>
				<p id="apresentacao">Administrador de Empresas, graduando em Análise e Desenvolvimento de Sistemas e terminando um MBA em Gestão Financeira. Sou apaixonado por tecnologia, podcasts, aprender coisas novas e desafios.</p>
			</div>
	        <ul class='navbar nav '>
				<li><a target="blank" href="https://github.com/Nathanbahia"><i class="fab fa-github-square"></i></a></li>
				<li><a target="blank" href="https://linkedin.com/in/nathanbahia"><i class="fab fa-linkedin"></i></a></li>
				<li><a target="blank" href="https://instagram.com/noobpythonbr"><i class="fab fa-instagram"></i></a></li>
			</ul>
	    </div>
	</footer>
	
    

    <script src="src/js/prism.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
  </body>
</html>
